---
title: "피보나치 수(DP)"
date: 2021-02-16
categories:
---

## Programmers-Level 2 - 피보나치 수
<br>

<b>* 문제 설명</b><br>

피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다.

예를들어

- F(2) = F(0) + F(1) = 0 + 1 = 1
- F(3) = F(1) + F(2) = 1 + 1 = 2
- F(4) = F(2) + F(3) = 1 + 2 = 3
- F(5) = F(3) + F(4) = 2 + 3 = 5

와 같이 이어집니다.

2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요.<br>

<br><b>* 제한 사항</b>

* n은 1이상, 100000이하인 자연수입니다.

<br>
입출력 예<br>

|     n|return|
|------|------|
|3     |2     |
|5     |5     |

<br>


문제출처 : <https://programmers.co.kr/learn/courses/30/lessons/12945?language=python3>

<br><br>

### 해결
* 풀이
    1. 피보나치 수의 경우 n이 커질수록 수행 시간이 기하급수적으로 늘어난다.    <br>
    2. DP(다이나믹 프로그래밍)의 기초이며 DP에 대해 정리하였다.     <br>

    
* 정리 
<br>

### | 소스코드(Python)
<br>

```python 
# 단순 재귀함수 사용
'''
def solution(n):
    answer = 0
    if n==1 or n==2:
        return 1
    return (solution(n-1)+solution(n-2))%1234567
'''
# 결과 : 런타임에러 및 시간초과

# 재귀함수(탑다운 다이나믹 프로그래밍)
'''
def solution(n):
    answer=0
    d=[0]*100001  # 한 번 계산된 결과를 메모이제이션하기 위한 리스트 초기화
    if n==1 or n==2:
        return 1
    if d[n]!=0:
        return d[n]
    d[n]=solution(n-1)+solution(n-2)
    return d[n]%1234567
'''
# 결과 : 런타임에러 및 시간초과


# 반복문(보텀업 다이나믹 프로그래밍)
def solution(n):
    d=[0]*100001  #DP 테이블 초기화
    d[1]=1
    d[2]=1
    for i in range(3,n+1):
        d[i]=d[i-1]+d[i-2]
    return d[n]%1234567
```

### | 다이나믹 프로그래밍(DP)
- 동적 계획법이라고도 불리며, 중복되는 연산을 줄이기 위함이 목적이다. 
- 속도나 메모리 공간의 한계로 제약이 발생하는 경우가 많은데 DP는 메모리공간을 더 사용하여 연산 속도를 비약적으로 증가시키는 방법이다. 
- 2가지(탑다운, 보텀업)방법이 있다. 
- 피보나치 수 처럼 반복되는 계산이 있어서 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 것이 다이나믹 프로그래밍이다. 
<br><br>
- 위의 두번째 풀이는 메모이제이션기법을 사용한 탑다운 방식이다. 
- 메모이제이션은 DP를 구현하는 방법 중 한 종류로, 한 번 연구한 결과를 메모리 공간에 저장해두고 같은 식을 호출할 때 가져오는 방법이다. 
- 하지만 두번째 풀이도 같은 반복으로 시간을 초과하여 일반적인 반복문을 사용한 DP가 성능이 좋다. 
- 반복문을 이용하여 작은 문제부터 하나씩 구해가는 보텀업 방식이 세번재 풀이이다. 
- 계산 결과를 저장하기 위한 리스트를 생성하고, n까지 반복하며 값을 하나씩 리스트에 넣어둔다. 
- 시간복잡도는 O(N)이며 한번 구한 결과는 다시 구하지 않으므로 성능이 좋음을 알 수 있다. 

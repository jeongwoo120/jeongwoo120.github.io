---
title: "땅따먹기"
date: 2021-03-31
categories: Coding_Test
---

## Programmers-Level 2 - 땅따먹기
<br>

<b>* 문제 설명</b><br>
땅따먹기 게임을 하려고 합니다. 땅따먹기 게임의 땅(land)은 총 N행 4열로 이루어져 있고, 모든 칸에는 점수가 쓰여 있습니다. 1행부터 땅을 밟으며 한 행씩 내려올 때, 각 행의 4칸 중 한 칸만 밟으면서 내려와야 합니다. 단, 땅따먹기 게임에는 한 행씩 내려올 때, 같은 열을 연속해서 밟을 수 없는 특수 규칙이 있습니다.

예를 들면,

| 1 | 2 | 3 | 5 |

| 5 | 6 | 7 | 8 |

| 4 | 3 | 2 | 1 |

로 땅이 주어졌다면, 1행에서 네번째 칸 (5)를 밟았으면, 2행의 네번째 칸 (8)은 밟을 수 없습니다.

마지막 행까지 모두 내려왔을 때, 얻을 수 있는 점수의 최대값을 return하는 solution 함수를 완성해 주세요. 위 예의 경우, 1행의 네번째 칸 (5), 2행의 세번째 칸 (7), 3행의 첫번째 칸 (4) 땅을 밟아 16점이 최고점이 되므로 16을 return 하면 됩니다.
 

<br><b>* 제한 사항 </b>

* 행의 개수 N : 100,000 이하의 자연수
* 열의 개수는 4개이고, 땅(land)은 2차원 배열로 주어집니다.
* 점수 : 100 이하의 자연수


<br><b>* 예제 입출력</b><br>

|land|answer|
|------|------|
|[[1,2,3,5],[5,6,7,8],[4,3,2,1]]|16|

<br>

문제출처 : <https://programmers.co.kr/learn/courses/30/lessons/12913>

<br><br>

### 해결
* 풀이
    1. DP를 활용하여 두번째 행부터 그 위의 행과의 합으로 만들 수 있는 최대값을 구해서 각 위치의 값으로 변경하며 저장해준다. 이러면 마지막 행까지 진행 했을 때 가장 큰 경우를 구할 수 있다. 
    2. 마지막 행까지 진행한 뒤, 마지막 행 중에서 가장 큰 값이 정답이 된다. 

    
* 정리 
    - 처음에는 단순히 행마다 가장 큰값을 더해주고, 그 위치는 다음행에서 밟지 않도록 구현했다. 
    - 하지만 [ [4, 3, 2, 1], [2, 2, 2, 1], [6, 6, 6, 4], [8, 7, 6, 5] ], <br>
    [ [1, 2, 3, 5], [5, 6, 7, 100], [4, 3, 2, 100] ]
    와 같은 경우에 대해서는 가장 큰 값을 리턴하지 못했다. 
    - 이 문제 역시 DP를 사용하면 어렵지 않게 해결할 수 있었는데... DP 문제를 많이 풀어봐야 한다. 각 행의 열의 개수가 4인것이 수상했는데, 4열이기에 DP로도 풀이가 가능했다. 
    - 문제에 주어진 케이스 외에도 간단히 풀릴 경우, 다양한 케이스를 시도하는 버릇을 가져야겠다. 


<br>

### | 소스코드(Python)
```python
# 첫번째 시도 -> 전체 실패
def solution_0(land):
    answer = 0
    answer += max(land[0])
    visit = land[0].index(max(land[0]))
    for i in range(1, len(land)):
        for j in range(4):
            if j==visit:
                land[i][j]=-1
        answer += max(land[i])
        visit = land[i].index(max(land[i]))  

    return answer

# DP로 풀이
def solution(land):
    answer=0
    for i in range(1,len(land)):
        land[i][0]=max(land[i][0]+land[i-1][1],land[i][0]+land[i-1][2],land[i][0]+land[i-1][3])
        land[i][1]=max(land[i][1]+land[i-1][0],land[i][1]+land[i-1][2],land[i][1]+land[i-1][3])
        land[i][2]=max(land[i][2]+land[i-1][0],land[i][2]+land[i-1][1],land[i][2]+land[i-1][3])
        land[i][3]=max(land[i][3]+land[i-1][0],land[i][3]+land[i-1][1],land[i][3]+land[i-1][2])
    return max(land[i])
```
<b>* 예제 풀이</b>
 
[1, 2, 3, 5] <br>[5, 6, 7, 100]<br>[4, 3, 2, 100] <br>
의 경우 DP로 계산을 하면 최종적으로 <br>

[1, 2, 3, 5]<br>[10, 11, 12, 103]<br>[107, 106, 105, 112]<br>
로 계산이 된다. 

마지막 행에서의 최대값 112가 정답이다.